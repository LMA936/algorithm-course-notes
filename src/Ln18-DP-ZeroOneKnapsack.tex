\chapter{动态规划之01背包问题}

\begin{introduction}
	\item 问题引入
	\item 基本思路
	\item 算法优化
	\item DP初始化问题
	\item 01背包小结
\end{introduction}

\section{问题引入}
现有$N$件物品和一个容量为$V$的背包，放入第i件物品耗费的背包容量是$C_i$，得到的价值是$W_i$。现在要求在限定的背包总重量内进行物体的选择装入，求解将哪些物品装入背包可以使背包内所装物品的价值总和最大。
\section{基本思路}

\subsection{贪心法}
下面将举例说明贪心法无法得到0-1背包问题的最优解。给出物体列表以及属性如下表所示：

\begin{center}
\begin{tabular}{cccccc}
\toprule  %添加表格头部粗线
W& 20& 30& 40& 50& 60\\
\midrule  %添加表格中横线
P& 20& 30& 44& 55& 60\\
P/W& 1& 1& 1.1& 1.1& 1\\
\bottomrule %添加表格底部粗线
\end{tabular}
\end{center}

对于满足满足总重量限制为100，根据\textbf{贪心算法的解以及最优解对比如下表所示}：

\begin{center}
\begin{tabular}{ccccccc}
\toprule  %添加表格头部粗线
选择策略& x1& x2& x3& x4& x5& 总价值\\
\midrule  %添加表格中横线
最小重量优先& 1& 1& 1& 0& 0& 94\\
最大价格优先& 0& 1& 0& 0& 1& 101\\
P/W 最大优先& 0& 0& 1& 1& 0& 99\\
= 实际最优解 =& 1& 1& 0& 1& 0& \textbf{105}\\ 
\bottomrule %添加表格底部粗线
\end{tabular}
\end{center}

可见\textbf{事实证明贪心算法无法得到01背包问题最优解}，因此在设计算法时不应该使用贪心策略。

\subsection{动态规划法}
背包问题具有最优子结构性质，所谓最优子结构性质是指一个问题的最优解中所包含的所有子问题的解都是最优的，所以可以用动态规划法去得到正确的解。这是最基本的背包问题，特点是：每种物品仅有一件，可以选择放或者不放。
用子问题定义状态：即 $F[i, V]$ 表示前 $i$ 件物品恰放入一个容量为 $V$ 的背包可以获得的最大价值。则其状态转移方程便是：
$$
F[i, V] = \max{\{F[i-1, V], F[i-1, V-C_i] + W_i\}}
$$
这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所
以有必要将它详细解释一下：“将前$i$件物品放入容量为$V$的背包中”这个子问题，若只考虑第 $i$ 件物品的策略（放或不放），那么就可以转化为一个只和前 $i-1$ 件物品相关的问题。如果不放第 $i$ 件物品，那么问题就转化为“前 $i-1$ 件物品放入容量为 $V$ 的背包中”，价值为 $F[i-1, V]$；如果放第 $i$ 件物品，那么问题就转化为“前 $i-1$ 件物品放入剩下的容量为 $V-C_i$ 的背包中”，此时能获得的最大价值就是 $F[i-1, V-C_i]$ 再加上
通过放入第 $i$ 件物品获得的价值 $W_i$。伪代码如下,其中ItemsInfo是物品信息，N，V如题目描述中所述：

\begin{lstlisting}[language=python, caption = 伪代码实现--ZeroOneKnapsack]
def ZeroOneKnapsack(ItemsInfo,N,V):
    for i in range(V+1):
        F[0,i] = 0
    for i in range(1,N+1):
        for v in range(Ci,V+1):
            F[i,v] = max(F[i-1,v],F[i-1,v-Ci]+Wi) 
    return F[N,V]
\end{lstlisting}

\section{算法优化}
\subsection{优化空间复杂度}
以上方法的时间和空间复杂度均为$O(V \times N)$，其中时间复杂度应该已经不能再优化
了，但\textbf{空间复杂度却可以优化到 O(V)}。
先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i$从$1$一直到$N$，每次算出来
二维数组$F[i, 0...V]$的所有值。那么，如果只用一个数组 $F[0...V]$，能不能保证第 $i$次循环结束后 $F[v]$ 中表示的就是我们定义的状态 $F[i, v]$ 呢？$F[i, v]$ 是由 $F[i-1, v]$ 和$F[i-1, V-C_i]$ 两个子问题递推而来，能否保证在推 $F[i, V]$时(也即在第 i 次主循环中推 F[v] 时)能够取用 $F[i-1, V]$ 和 $F[i-1, V-C_i]$ 的值呢？
事实上，这\textbf{要求在每次主循环中我们让第二层循环的$v$从$V$到$C_i$的递减顺序计算 $F[v]$}，这样才能保证计算 $F[v]$ 时 $F[v-C_i]$ 保存的是状态 $F[i-1,v-C_i]$ 的值。伪代码如下：

\begin{lstlisting}[language=python, caption = 优化空间复杂度--二层循环倒序]
def ZeroOneKnapsack(ItemsInfo,N,V):
    for i in range(V+1):
        F[i] = 0
    for i in range(1,N+1):
        for v in range(V,Ci,-1):  //空间优化，一维数组即可
            F[v] = max(F[v],F[v-Ci]+Wi) 
    return F[V]
\end{lstlisting}

其中的一维状态转移方程$F[v] = max(F[v], F[v-C_i] + W_i)$ ，恰就对应于我们原来的二维转移方程，因
为现在的 $F[v-C_i]$ 就相当于原来的 $F[i-1, v-C_i]$。如果将$ v $的循环顺序从上面的逆
序改成顺序的话，那么则成了 $F[i, v] 由 F[i, v-C_i]$ 推导得到，则没有用到上一轮$i-1$对应的状态，与本题意不符。

\subsection{一个常数优化}
\textbf{上面空间优化之后伪代码中的第二重循环$V \rightarrow C_i$的下限$C_i$也可以可以改进}。它可以被优化为$max(V-\sum_{i}^{N}C_i,C_i)$，所以二层循环伪代码就可以变成：
\begin{lstlisting}[language=python, caption = 一个常数优化] 
    for v in range(V, max(V - sum(Ci_List), Ci), -1):  //空间优化 + 常数优化
\end{lstlisting}
这个优化之所以成立的原因可以使用最初始二维的状态转移方程思考一下。

\section{DP初始化问题}
我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。\textbf{有的题目
要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满}。这两种问法的实现方法是在初始化的时候有所不同。
如果是第一种问法，要求恰好装满背包，那么在初始化时除了 $F[0]$ 为 $0$，其它
$F[1...V]$ 均设为 $-\infty$，这样就可以保证最终得到的 $F[V]$ 是一种恰好装满背包的最优解。
如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 $F[0..V]$
全部设为 $0$。
这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放
入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 $0$ 的背包可以在什
么也不装且价值为 $0$ 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于
未定义的状态，应该被赋值为$-\infty$了。如果背包并非必须被装满，那么任何容量的背包
都有一个合法解“什么都不装”，这个解的价值为$ 0$，所以初始时状态的值也就全部为 $0$
了。这个小技巧完全可以推广到其它类型的背包问题，初始化的细节就在于初始状态的定义。


\section{背包问题小结}
01 背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思
想。另外，别的类型的背包问题往往也可以转换成 01 背包问题求解。故一定要仔细体
会上面基本思路的得出方法，状态转移方程的意义，以及空间复杂度怎样被优化。

对于背包问题，0-1背包问题只是最简单最基本的一种，也可以再看看更复杂的背包问题。
\begin{itemize}
	\item 完全背包问题
	\item 多重背包问题
	\item 混合三种背包问题
\end{itemize}


